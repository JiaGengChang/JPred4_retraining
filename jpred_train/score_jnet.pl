#!/cluster/gjb_lab/2472402/miniconda/envs/jnet/bin/perl

=head1 NAME

score_jnet.pl - script to generate and score Jnet predictions

=cut

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use File::Basename;

use lib '/cluster/gjb_lab/2472402/jpred_train/lib';
use Jpred::Scores qw(score_simple score_per_res);
use Jpred::jnetDB;
use Jpred::Utils 0.4;    # requires this version in order to use the 'hard' DSSP 8->3 state conversion

my %allowedItems = qw(jnetpred 1 jnetsol0 1 jnetsol5 1 jnetsol25 1 jnetpssm 1 jnetfreq 1 jnethmm 1 jnetalign 1);

my $path;                 # path to data
my $jnetPath;             # path to Jnet binary
my $searchItems;
my $JNETV       = 2.1;
my $out;                  # filename for jnet scores
my $del         = 0;      # toggle deletion of files
my $hard        = 0;
my $Qall        = 0;
my $sov         = 0;

my $VERBOSE = 0;
my $DEBUG   = 0;
my $help;
my $man;

GetOptions(
  'data=s'         => \$path,
  'jnet=s'         => \$jnetPath,
  'jnet-version=f' => \$JNETV,
  'pred-items=s'   => \$searchItems,
  'out=s'          => \$out,
  'sov'            => \$sov,
  'delete!'        => \$del,
  'hard!'          => \$hard,

  'help|?'  => \$help,
  'man'     => \$man,
  'verbose' => \$VERBOSE,
  'debug'   => \$DEBUG
) or pod2usage();

pod2usage( -verbose => 1 )                                             if ($help);
pod2usage( -verbose => 2 )                                             if ($man);
pod2usage( -msg     => "Give a path for the location of datafile.\n" ) if ( !$path );

##################################################################################################################################
my @items;
if ( $searchItems =~ /qall/ ) {
  @items = qw(jnetpred);
  $Qall  = 1;
} else {
  @items = split( /\,/, $searchItems );
}
pod2usage( -msg => "Please provide a list of prediction strings separated by commas.\n" ) if ( !@items && !$sov );

# check requested elements are valid
foreach my $i (@items) {
  die "ERROR! '$i' not a valid prediction string.\nDied" if ( !$allowedItems{$i} );
}

$del = 0 if ( !$jnetPath );    # don't delete *.jnet files if not generated by this script

my $dbh      = connect_DB('jnet-user');
my $accData  = get_accDB($dbh);
my $dsspData = get_DSSP($dbh);
$dbh->disconnect unless ($sov);

##################################################################################################################################
# prepare jnet files for estimating accuracy
#
my @files;
if ($jnetPath) {
  run_jnet( $jnetPath, $path );
  @files = glob "*.jnet";
  die "ERROR - no Jnet files found/\nDied" if ( !@files );
} else {
  print "Old Jnet caclucations are being used...\n";
  @files = glob "$path/*.jnet";
  die "ERROR - no Jnet files found in '$path'.\nDied" if ( !@files );
}

open( my $CSV, '>', $out ) or die "ERROR! unable to open file '$out': $!\nDied";
if ($Qall) {
  print $CSV "#Hcorrect,Htotal,Ccorrect,Ctotal,Ecorrect,Etotal,Ncorrect,Ntotal\n";
} else {
  #print $CSV "#seqID,$searchItems\n";
  print $CSV ($sov) ? "SeqID,sov,$searchItems\n"  : "SeqID,$searchItems\n";
}

my %perResTotals;

##################################################################################################################################
# estimate accuracy domain by domain
#
foreach my $file (@files) {
  my $id;
  if ( $file =~ /(\d+)\.jnet/ ) {
    $id = $1;
  }
  unless ($id) {
    warn "WARNING! unable to open file '$file', estimation for the domain is impossible";
    next;
  }

  # retrieve accessibility and DSSP data for sequence
  my $relAcc = acc2rel( $accData->{$id}{acc}, $accData->{$id}{seq} );
  if ( !scalar @$relAcc && ( $searchItems =~ /jnetsol/i ) ) {
    die "ERROR! no solvent accessibility data found for '$id'. Died\n"    # only worry about lack of solvent data if required in output
  }

  my $dssp = reduce_dssp( $dsspData->{$id}{dssp}, $hard );
  die "ERROR! no DSSP data found for '$id'\n" if ( !$dssp );

  # get solacc|structure prediction and output score
  print $CSV "$id" unless ($Qall);
  open( my $DATA, $file ) or die "Can't open file '$file': $!. Died";
  if ($sov) {
    my $sovScore = sov_score( $DATA, $dssp, $id );
    print $CSV ",$sovScore";
    # print $CSV ",$sovScore\n";
    # next;
  }

  foreach my $item (@items) {
    if ( $item =~ /sol(\d+)/ ) {

      # solvent accessibility predictions
      my $cut       = $1;
      my $accString = acc2str( $relAcc, $cut );
      my $pred      = get_item( $DATA, $item );
      die "ERROR - no $cut\% solacc prediction found in '$file'\n" if ( !$pred );
      my $score = score_simple( $pred, $accString );
      printf $CSV ",%.2f", $score;
    } else {

      # secondary structure predictions
      my $pred = get_item( $DATA, $item );
      die "ERROR - no SS '$item' prediction found in '$file'\n" if ( !$pred );
      if ($Qall) {
        score_per_res( $pred, $dssp, \%perResTotals );
      } else {
        my $score = score_simple( $pred, $dssp );
        printf $CSV ",%.2f", $score;
      }
    }
  }
  print $CSV "\n" unless ($Qall);
  close($DATA);
}

unlink( glob "*.jnet" ) if ($del);

if ($Qall) {
  my $tot;
  my $corr;
  foreach my $type (qw(H - E N)) {
    print $CSV "$perResTotals{$type}{correct},$perResTotals{$type}{total},";
  }
  print $CSV "\n";
}
close($CSV);
exit;

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
sub sov_score {
  use Jpred::SOV;
  my $fh    = shift;
  my $dssp  = shift;
  my $seqID = shift;

  my $seq = get_seq( $dbh, $seqID );
  # my $pred = get_item( $fh, 'jnetpred' );
  my $pred = get_item( $fh, 'JNETPSSM' ); # jia geng
  my $sovIn = "$seqID.sov.in";

  open( my $SOV, ">", $sovIn ) or die "ERROR - unable to open '$sovIn' for write: ${!}\nDied";
  my $sov = Jpred::SOV->new( input => $sovIn, output => "$seqID.sov.out");
  $sov->write( dssp => $dssp, pred => $pred, seq => $seq );
  $sov->run();
  my $score = $sov->score;

  return $score;
}

##################################################################################################################################
# function for converting an array of relative solvent accessibilies into a exposed/buried Q2 string
#
sub acc2str {
  my $relAcc = shift;
  my $cut    = shift;
  my $length = scalar @$relAcc;

  die "ERROR! solvent accessibility data has zero length. Died\n" if ( $length == 0 );

  my $string;
  for ( my $i = 0 ; $i < $length ; ++$i ) {
    if ( $relAcc->[$i] > $cut ) {
      $string .= '-';
    } else {
      $string .= 'B';
    }
  }
  die "ERROR! string is not the same length as the data. Died\n" if ( length($string) != $length );
  return $string;
}

##################################################################################################################################
# function to run jnet for a set of sequences from directory
#
sub run_jnet {
  my $binPath  = shift;
  my $dataPath = shift;

  die "ERROR! jnet not found at '$binPath'. Died\n" if ( !-e "$binPath/jnet" );
  my @files = glob "$dataPath/*.hmm";
  die "ERROR! no datafile found in '$dataPath'. Died\n" if ( !scalar @files );

  unlink( glob "*.jnet" );    # remove any pre-existing files to avoid conflicts
  printf "Running %d Jnet predictions...\n", scalar @files;
  foreach my $file (@files) {
    my $id = basename( $file, 'hmm' );
    $id =~ s/\.//;

    if ( $JNETV < 2 ) {

      # very old jnet
      my $cmd =
        "$binPath/jnet --concise --sequence $dataPath/$id.align --hmmer $dataPath/$id.hmmprof --psiprof $dataPath/$id.pssm --psifreq $dataPath/$id.freq > $id.jnet 2>/dev/null";
      print "Command: $cmd" if ($DEBUG);
      system($cmd ) == 0 or die "ERROR! unable to run JNet for '$id'. Died\n";
    } else {

      # current jnet
      my $cmd = "$binPath/jnet --concise --hmmer $dataPath/$id.hmm --pssm $dataPath/$id.pssm > $id.jnet 2>/dev/null";
      #my $cmd = "$binPath/jnet --concise --hmmer $dataPath/$id.hmm > $id.jnet 2>/dev/null";
      print "Command: $cmd" if ($DEBUG);
      system($cmd ) == 0 or die "ERROR - unable to run JNet for '$id'. Died\n";
    }
  }
}

##################################################################################################################################

=head1 SYNOPSIS

score_jnet.pl -data <data path> [-jnet <jnet path>] [-jnet-version <version number>] [-pred-items <list>] [-hard|-nohard] [-out <filename>] [-delete|-nodelete] [-sov]

=head1 DESCRIPTION

This script simplifies the running and/or scoring of Jnet on a set of data.

At the very least supply a path where a bunch of *.jnet files are and 
the script will parse them and derive a score for each of them for secondary 
structure and solvent accessbility at 0%, 5% and 25% relative cutoffs.

If however, the data path doesn't contain *.jnet files then you must provide 
the path to a I<jnet> binary in order to generate the Jnet predictions. 
Once the predictions are made, the scores are derived as above.

=head1 OPTIONS

=over 8

=item B<-data> <data path>

Path to data. The user needs to ascertain whether path points to a series of *.jnet files or a series of Jnet input files.

If the the path points to a series of input files the B<-jnet> argument also needs to be set.

=item B<-jnet> <jnet binary>

B<Optional.>

Path to the Jnet binary for determining the predictions for the input files found at B<-data>.

If this option is set then the script assumes the data in B<-data> is input data for Jnet.

=item B<-jnet-version> <version number>

B<Optional.>

Define which version of Jnet is being used as the input parameters changed from v1.0 to v2.x

Default = 1.0;

=item B<-pred-items> <list>

B<Optional.>

Comma separated list of prediction data that you want to score.

Allowed values are: jnetpred, jnetsol0/5/25, jnethmm, jnetpssm, jnetfreq, jnetalign, Qall.

Qall overrides the other options and will provide a breakdown of QH,QC, QE and QN (helix start pos) along with the default Q3 score.

Default: jnetpred,jnetsol0,jnetsol5,jnetsol25

=item B<-hard|-nohard>

Toggle to specify whether to use 'hard' DSSP 8->3 conversion. Default[-nohard].

=item B<-out> <filename>

output filename [default: score_jnet.csv]

=item B<-delete|-nodelete>

Toggle deletion of *.jnet output files created suring running of script. [default: -delete]

=item B<-sov>

B<Optional.>

Output SOV score instead of Q3. This option will ignore the B<-pred-items> argument

=back
  
=head1 AUTHOR
  
Chris Cole <christian@cole.name>
  
=cut

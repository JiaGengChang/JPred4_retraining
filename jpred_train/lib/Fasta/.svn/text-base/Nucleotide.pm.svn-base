package Fasta::Nucleotide;

our $VERSION = '0.1';

=head1 NAME 

Fasta::Nucleotide - Nucleotide-specific module for use with fasta-formatted files

=head1 SYNOPSIS

use Fasta::Utils;
use Fasta::Nucleotide;

my %aa;
my $seq_ref = parse('fasta_file');

foreach my $seqID (keys %$seq_ref) {
   # translate all the DNA sequences in reading frame -2
   $aa{$seqID} = trans($seq_ref->{$seqID}{seq}, -2)
}

=head1 DESCRIPTION

Currently the module only has one function: trans() which prints the protein sequence for each reading frame of a dna seq. Default: frame +1.

The functions deals with the amibuous codons (R, Y, M, K, S, W, H, B, V, D and N) by returning all allowed residues as a list in brackets e.g. MS(AAGF)TTR...

=head1 CAVEATS

Currently the module only copes with one ambiguity per codon. If more than 
one ambiguity per codon is found the module will fail.

=head1 AUTHOR

Chris Cole <christian@cole.name>.

=head1 COPYRIGHT

Copyright 2006, Chris Cole.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=head1 SEE ALSO

Fasta::Utils

=cut

use strict;
use warnings;
use Exporter;

our @ISA    = qw(Exporter);
our @EXPORT = qw(trans);

my %aa = (
  'ALA', "A", 'ARG', "R", 'ASN', "N", 'ASP', "D", 'CYS', "C", 'GLN', "Q", 'GLU', "E", 'GLY', "G", 'HIS', "H", 'ILE', "I", 'LEU', "L",
  'LYS', "K", 'MET', "M", 'PHE', "F", 'PRO', "P", 'SER', "S", 'THR', "T", 'TRP', "W", 'TYR', "Y", 'VAL', "V", 'GLX', "X"
);
my %rosetta =
  qw(TTT PHE TCT SER TAT TYR TGT CYS TTC PHE TCC SER TAC TYR TGC CYS TTA LEU TCA SER TAA STOP TGA STOP TTG LEU TCG SER TAG STOP TGG TRP CTT LEU CCT PRO CAT HIS CGT ARG CTC LEU CCC PRO CAC HIS CGC ARG CTA LEU CCA PRO CAA GLN CGA ARG CTG LEU CCG PRO CAG GLN CGG ARG ATT ILE ACT THR AAT ASN AGT SER ATC ILE ACC THR AAC ASN AGC SER ATA ILE ACA THR AAA LYS AGA ARG ATG MET ACG THR AAG LYS AGG ARG GTT VAL GCT ALA GAT ASP GGT GLY GTC VAL GCC ALA GAC ASP GGC GLY GTA VAL GCA ALA GAA GLU GGA GLY GTG VAL GCG ALA GAG GLU GGG GLY);

sub trans {

  my ( $dna, $frame ) = @_;

  die "Frame must be an integer between +3 and -3" if ( abs($frame) > 3 );

  if ( !$frame ) {
    $frame = 1;
  }

  my $aa_seq;

  if ( $frame > 0 ) {
    $frame -= 1;
    $aa_seq = print_frame( $dna, $frame );
  } else {
    my $cdna = reverse($dna);
    $cdna =~ tr/ATGC/TACG/;

    $frame += 1;
    $aa_seq = print_frame( $cdna, abs($frame) );
  }
  return ($aa_seq);
}

sub print_frame {

  my ( $seq, $frame ) = @_ or return;

  my @bits = split //, $seq;
  my $end = length($seq);

  my $aa_seq;

  for ( my $i = int($frame) ; $i < $end - 2 ; $i += 3 ) {
    my $codon = $bits[$i] . $bits[ $i + 1 ] . $bits[ $i + 2 ];

    if ( !exists( $rosetta{$codon} ) ) {
      if ( length($codon) != 3 ) {
        print "\n$codon codon out of frame\n";
        next;
      } else {

        # insert sub to deal with ambiguous bases here...
        #print "\nERROR - $codon codon is unknown\n";
        $aa_seq .= sprintf "(%s)", ambiguous($codon);
        next;
      }
    }
    if ( $rosetta{$codon} =~ /stop/i ) {
      $aa_seq .= '*';
    } else {
      $aa_seq .= $aa{ $rosetta{$codon} };
    }
  }
  return ($aa_seq);
}

sub ambiguous {

  # takes codon with ambiguous base and returns
  # all the possible amino acids generated by the
  # ambiguity.

  #** NB: can only cope with one ambiguity per codon
  #** at the moment - need to change.

  # look-up table for ambiguous bases
  my %ambi_base = qw(R A:G Y C:T M A:C K G:T S G:C W A:T H A:C:T B C:G:T V A:C:G D A:G:T N A:C:G:T);

  my $codon = shift;
  my $safe  = $codon;

  my @codes = split //, $codon;

  my $match = 0;

  my $aas;

  foreach my $code (@codes) {
    if ( $ambi_base{$code} ) {    # find the ambiguous code
      $match = 1;

      my @ambis = split /:/, $ambi_base{$code};
      foreach my $subs (@ambis) {
        $codon =~ s/$code/$subs/;

        if ( !exists( $rosetta{$codon} ) ) {
          print "\nERROR - >1 ambiguous bases in codon $codon\n";
          exit;
        }
        if ( $rosetta{$codon} =~ /stop/i ) {
          $aas .= '*';
        } else {
          $aas .= $aa{ $rosetta{$codon} };
        }
        $codon = $safe;
      }
      last;
    }
  }
  die "\nERROR - ambiguous base in codon $codon is unrecognised" if !$match;
  return ($aas);
}

1;
